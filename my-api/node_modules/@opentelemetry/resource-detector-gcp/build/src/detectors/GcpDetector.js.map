{"version":3,"file":"GcpDetector.js","sourceRoot":"","sources":["../../../src/detectors/GcpDetector.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as gcpMetadata from 'gcp-metadata';\nimport { diag } from '@opentelemetry/api';\nimport {\n  Detector,\n  ResourceDetectionConfig,\n  Resource,\n  ResourceAttributes,\n} from '@opentelemetry/resources';\nimport { getEnv } from '@opentelemetry/core';\nimport {\n  CloudProviderValues,\n  SemanticResourceAttributes,\n} from '@opentelemetry/semantic-conventions';\n\n/**\n * The GcpDetector can be used to detect if a process is running in the Google\n * Cloud Platform and return a {@link Resource} populated with metadata about\n * the instance. Returns an empty Resource if detection fails.\n */\nclass GcpDetector implements Detector {\n  /**\n   * Attempts to connect and obtain instance configuration data from the GCP metadata service.\n   * If the connection is successful it returns a promise containing a {@link Resource}\n   * populated with instance metadata. Returns a promise containing an\n   * empty {@link Resource} if the connection or parsing of the metadata fails.\n   *\n   * @param config The resource detection config\n   */\n  async detect(_config?: ResourceDetectionConfig): Promise<Resource> {\n    if (!(await gcpMetadata.isAvailable())) {\n      diag.debug('GcpDetector failed: GCP Metadata unavailable.');\n      return Resource.empty();\n    }\n\n    const [projectId, instanceId, zoneId, clusterName, hostname] =\n      await Promise.all([\n        this._getProjectId(),\n        this._getInstanceId(),\n        this._getZone(),\n        this._getClusterName(),\n        this._getHostname(),\n      ]);\n\n    const attributes: ResourceAttributes = {};\n    attributes[SemanticResourceAttributes.CLOUD_ACCOUNT_ID] = projectId;\n    attributes[SemanticResourceAttributes.HOST_ID] = instanceId;\n    attributes[SemanticResourceAttributes.HOST_NAME] = hostname;\n    attributes[SemanticResourceAttributes.CLOUD_AVAILABILITY_ZONE] = zoneId;\n    attributes[SemanticResourceAttributes.CLOUD_PROVIDER] =\n      CloudProviderValues.GCP;\n\n    if (getEnv().KUBERNETES_SERVICE_HOST)\n      this._addK8sAttributes(attributes, clusterName);\n\n    return new Resource(attributes);\n  }\n\n  /** Add resource attributes for K8s */\n  private _addK8sAttributes(\n    attributes: ResourceAttributes,\n    clusterName: string\n  ): void {\n    const env = getEnv();\n\n    attributes[SemanticResourceAttributes.K8S_CLUSTER_NAME] = clusterName;\n    attributes[SemanticResourceAttributes.K8S_NAMESPACE_NAME] = env.NAMESPACE;\n    attributes[SemanticResourceAttributes.K8S_POD_NAME] = env.HOSTNAME;\n    attributes[SemanticResourceAttributes.CONTAINER_NAME] = env.CONTAINER_NAME;\n  }\n\n  /** Gets project id from GCP project metadata. */\n  private async _getProjectId(): Promise<string> {\n    try {\n      return await gcpMetadata.project('project-id');\n    } catch {\n      return '';\n    }\n  }\n\n  /** Gets instance id from GCP instance metadata. */\n  private async _getInstanceId(): Promise<string> {\n    try {\n      const id = await gcpMetadata.instance('id');\n      return id.toString();\n    } catch {\n      return '';\n    }\n  }\n\n  /** Gets zone from GCP instance metadata. */\n  private async _getZone(): Promise<string> {\n    try {\n      const zoneId = await gcpMetadata.instance('zone');\n      if (zoneId) {\n        return zoneId.split('/').pop();\n      }\n      return '';\n    } catch {\n      return '';\n    }\n  }\n\n  /** Gets cluster name from GCP instance metadata. */\n  private async _getClusterName(): Promise<string> {\n    try {\n      return await gcpMetadata.instance('attributes/cluster-name');\n    } catch {\n      return '';\n    }\n  }\n\n  /** Gets hostname from GCP instance metadata. */\n  private async _getHostname(): Promise<string> {\n    try {\n      return await gcpMetadata.instance('hostname');\n    } catch {\n      return '';\n    }\n  }\n}\n\nexport const gcpDetector = new GcpDetector();\n"]}